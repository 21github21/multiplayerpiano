// Generated by CoffeeScript 1.6.1
(function() {
  var ChordGenerator, Game, GameServer, MIDIUtil, app, events, express, fs, gameServer, http, io, server,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  express = require('express');

  events = require('events');

  app = express();

  http = require('http');

  fs = require('fs');

  app.use('/static', express["static"](__dirname + '/static'));

  server = http.createServer(app);

  server.listen(4000);

  io = require('socket.io').listen(server);

  ChordGenerator = (function(_super) {
    var NOTES_MAJOR, NOTES_MINOR, ROOTS, TYPES;

    __extends(ChordGenerator, _super);

    function ChordGenerator() {
      var _this = this;
      this.noteOff = function(note) {
        return ChordGenerator.prototype.noteOff.apply(_this, arguments);
      };
      this.noteOn = function(note) {
        return ChordGenerator.prototype.noteOn.apply(_this, arguments);
      };
      this.getRandomChord = function() {
        return ChordGenerator.prototype.getRandomChord.apply(_this, arguments);
      };
      return ChordGenerator.__super__.constructor.apply(this, arguments);
    }

    NOTES_MAJOR = [0, 4, 7];

    NOTES_MINOR = [0, 3, 7];

    ROOTS = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'G', 'G#', 'A', 'Bb', 'B'];

    TYPES = ['Major', 'Minor'];

    ChordGenerator.target = null;

    ChordGenerator.notes = [];

    ChordGenerator.prototype.getRandomChord = function() {
      return this.current = ROOTS[Math.floor(Math.random() * ROOTS.length)];
    };

    ChordGenerator.prototype.noteOn = function(note) {
      return this.notes.push(note);
    };

    ChordGenerator.prototype.noteOff = function(note) {
      return this.notes = this.notes.filter(function(x) {
        return x !== note;
      });
    };

    return ChordGenerator;

  })(events.EventEmitter);

  exports.ChordGenerator = ChordGenerator;

  Game = (function(_super) {

    __extends(Game, _super);

    function Game() {
      var _this = this;
      this.end = function() {
        return Game.prototype.end.apply(_this, arguments);
      };
      this.newTurn = function() {
        return Game.prototype.newTurn.apply(_this, arguments);
      };
      this.start = function() {
        return Game.prototype.start.apply(_this, arguments);
      };
      this.addPlayer = function(player) {
        return Game.prototype.addPlayer.apply(_this, arguments);
      };
      console.log("Starting a new game.");
      this.players = [];
      this.chordGenerator = new ChordGenerator;
      this.score = 0;
      this.timeout = null;
      this.notes = [];
    }

    Game.prototype.addPlayer = function(player) {
      console.log("Adding player (game)");
      return this.players.push(player);
    };

    Game.prototype.start = function() {
      var p, _i, _len, _ref;
      console.log("Starting game.");
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        p.emit('gameStart');
      }
      return this.newTurn();
    };

    Game.prototype.newTurn = function() {
      var p, target, _i, _len, _ref, _results;
      console.log("New turn.");
      if (this.timeout != null) {
        clearTimeout(this.timeout);
      }
      this.timeout = setTimeout(this.end, 10000 - (1000 * this.score));
      target = this.chordGenerator.getRandomChord();
      console.log("Broadcasting target " + target + " to all players.");
      _ref = this.players;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.emit('target', target));
      }
      return _results;
    };

    Game.prototype.end = function() {
      var p, _i, _len, _ref, _results;
      console.log("Game over; players scored " + this.score);
      _ref = this.players;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.emit('gameOver', this.score));
      }
      return _results;
    };

    return Game;

  })(events.EventEmitter);

  GameServer = (function(_super) {

    __extends(GameServer, _super);

    GameServer.PLAYERS_PER_GAME = 1;

    function GameServer() {
      this.waitingroom = [];
      this.games = [];
    }

    GameServer.prototype.addPlayer = function(player) {
      var game, i, _i, _ref;
      console.log("Adding player (gameserver).");
      this.waitingroom.push(player);
      if (this.waitingroom.length >= GameServer.PLAYERS_PER_GAME) {
        game = new Game;
        for (i = _i = 1, _ref = GameServer.PLAYERS_PER_GAME; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          game.addPlayer(this.waitingroom.pop());
        }
        return game.start();
      }
    };

    return GameServer;

  })(events.EventEmitter);

  MIDIUtil = (function() {

    function MIDIUtil() {}

    MIDIUtil.NOTES = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'G#', 'A', 'Bb', 'B'];

    MIDIUtil.prototype.midiToNoteName = function(num) {
      var target;
      target = num % MIDIUtil.NOTES.length;
      return MIDIUtil.NOTES[target];
    };

    MIDIUtil.prototype.offsetFromRoot = function(root, target) {
      var end, start;
      start = MIDIUtil.NOTES.indexOf(root);
      end = MIDIUtil.NOTES.indexOf(target);
      if (end >= start) {
        return end - start;
      } else {
        return (MIDIUtil.NOTES.length - start) + end;
      }
    };

    return MIDIUtil;

  })();

  exports.MIDIUtil = MIDIUtil;

  gameServer = new GameServer;

  app.get('/', function(req, res) {
    return fs.createReadStream('./views/index.html').pipe(res);
  });

  io.sockets.on('connection', function(socket) {
    gameServer.addPlayer(socket);
    socket.on('note_on', function(note) {
      return socket.broadcast.emit('note_on', note);
    });
    return socket.on('note_off', function(note) {
      return socket.broadcast.emit('note_off', note);
    });
  });

}).call(this);
